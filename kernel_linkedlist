
#include <linux/list.h>
#include <linux/malloc.h>


struct object_store {
	struct list_head head_of_list;  // kernel's list structure 
	struct mutex resource_lock;
	unsigned long size;
	unsigned long offset;
	unsigned long virt_addr;
};

struct object_store myobjectlist;		// Declaration-- of List Head

/* MOVE TO npheap_init() ---------------------------> */ INIT_LIST_HEAD(&myobjectlist.head_of_list);



/* MOVE TO npheap_init() ---------------------------> When calling insert_object, pass myobjectlist->head_of_list */
// Inserts a Node at tail of Doubly linked list
void insert_object(unsigned long size,unsigned long offset,unsigned long virt_addr, struct list_head *head) {

	struct object_store *new = (struct object_store*)kmalloc(sizeof(struct object_store),GFP_KERNEL);
	
	new->size = size;
	new->offset = offset;
	new->virt_addr = virt_addr;
	
	list_add_tail(new, head); 

}

// ---------------> How to call this function ------------>      /* delete_object (offset); */

// Deletes an entry from the list 
void delete_object(unsigned long offset) {

/* @pos:	the &struct list_head to use as a loop cursor.
 * @n:		another &struct list_head to use as temporary storage
 * @head:	the head for your list.

 	list_for_each_safe(pos, n, head)
*/	
	struct list_head *pos, *temp_store;
	printk("deleting the list using list_for_each_safe()\n");
	
	list_for_each_safe(pos, temp_store, myobjectlist->head_of_list) {

		if(((struct object_store *)pos)->offset == offset) {
			list_del(pos);
		    kfree(pos);
		    return;	
		}
	}	 
}


// Searches for the desired object-id
struct object_store *get_object(unsigned long offset) {

/* This macro creates a for loop that executes once with cursor pointing at
   each successive entry in the list. Be careful about changing the list while
   iterating through it.
   @pos: the &struct list_head to use as a loop cursor
   @head: the head for your list

   	list_for_each(pos, head)
 */
	struct list_head *pos;
	printk("Searching the list using list_for_each()\n");
	
	list_for_each(pos, myobjectlist->head_of_list) {

		if(((struct object_store *)pos)->offset == offset) {
			return (((struct object_store *)pos));
	    }
    }
} 


// Print nodes of linked list
void list_print() {

	struct list_head *pos;
	printk("\nPrinting contents of the linked list:\n");

	list_for_each(pos, myobjectlist->head_of_list) {
		printk("Size:%lu,\nOffset:%lu,\nVirtual Address:%lu\n\n\n",((struct object_store *)pos)->size,\
		 ((struct object_store *)pos)->offset, ((struct object_store *)pos)->virt_addr);
	}

}





